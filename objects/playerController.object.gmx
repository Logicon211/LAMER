<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>player_s</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1234567</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/***************************************************
  state - string variable
    The playerObject's state is how the rest
    of it's separate parts (head, arms, legs core)
    know how to function, move, and act. It is a
    critical part of the animations and actions.
 ***************************************************/

state = string('normal');

/***************************************************
  States are as follows

    'normal':   In the Nromal state, the
                Player can move, boost, and 
                enter all other states.

    'tonorm':   The To-Normal state is used
                as a transition from any state
                in to the Normal state. It 
                eases animations and positions
                to appear smoother, and ends
                after a short counter.
    
    'shield':   The Shield state is a priority
                state, in which most other states
                cannot be activated. It exits
                to the To-Normal state when 
                the player releases the shield
                button.
                
    'slideL':   The Slide-Left state can be viewed
                as a dodge roll. It is achieved by
                recieving left input button while
                in the Shield state.
                
    'slideR':   The Slide-Right state is the same
                as the Slide-Left state, but 
                dodges to the right instead of
                the left.
                
    'attack1':  Attack-One state is a specialized
                state that runs a script to determine
                it's actions and animations. The
                script is selected based on the
                arm equipped to attack slot one.
                
    'attack2':  Attack-Two state is a specialized
                state that runs a script to determine
                it's actions and animations. The
                script is selected based on the
                arm equipped to attack slot two.
                
    'kneel':    The Kneeling state occurs when
                the player presses and hold the
                down button. It disables movement
                and opens up a separate set of
                attacks for each arm/weapon.
                
 ***************************************************/

image_alpha = 0;
/***************************************************
  airborne - boolean
    is used to track if the player is 
    on the ground or in the air.
 ***************************************************/
airborne = true;
/***************************************************
  target_vspeed - float
  target_hspeed - float
    these variables are used to give a hoizontal
    and verticle target velocity. Setting the
    target_hspeed to 16 for example, will cause
    the player to accelerate to the right until
    hspeed=16. It will then maintain hspeed=16
    until target_hspeed is changed.
 ***************************************************/
target_vspeed = 0.0;
target_hspeed = 0.0;
/***************************************************
  boosting - boolean
    is used to track if the player is 
    using boosters or not. Boosting
    causes faster acceleration and 
    higher maximum velocities.
 ***************************************************/
boosting = false;

//walking = false; //dead variable???

/***************************************************
  Various counters are used for animation timing.
  They are all integers, and are all separated to
  avoid one animations timer conflicting with
  another animation.
 ***************************************************/
counter = 0;
shield_counter = 0;
jumpCounter = 100;
landCounter = 0;

boost_power = 1;
leg_speed = 1;
weight = 1;
attack1_type=0;
attack2_type=0;

//Create Core
core = instance_create(x,y,core_o)
//EDN Create Core

height = sprite_height+core.height;
headheight = core.headheight;
coreheight = core.sprite_height;
legheight = core.legheight;

attack1_type = core.attack1_type;
attack2_type = core.attack2_type;


//color blend test
color_tst = 0;
color_tst2 = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//quit game
if(quit_check())
{
    game_end();
}
//END quit game
//restart game
if(restart_check())
{
    game_restart();
}
//END restart game

/***************************************************
  Controls
 ***************************************************/
if(state=string('slideL'))
{
    with(shield_obj){instance_destroy()}
    x -= 300*boost_power/weight;
    state=string('tonorm'){}
    
}
else if(state=string('slideR'))
{
    with(shield_obj){instance_destroy()}
    x += 300*boost_power/weight;
    state=string('tonorm'){}
    
}
else
{
    //shield pressed
    if(shield_check())
    {
        core.gun_aim = 0;
        shield_counter += 1;
        if(state!=string('shield'))
        {
            shield_obj = instance_create(x,y,shield_o);
            state = string('shield');
        }
        target_hspeed = 0;
        shield_obj.x = core.x;
        shield_obj.y = core.y;
        if(shield_counter&gt;=1)
        {
            if(left_check_pressed())
            {
                state=string('slideL');
                shield_counter = -10;
            }
            if(right_check_pressed())
            {
                state=string('slideR');
                shield_counter = -10;
            }
        }
     
    }
    //shield released
    else if(shield_check_released())
    {
        core.gun_aim = 0;
        with(shield_obj){instance_destroy()}
        state = string('tonorm');
        shield_counter = 0;
    }
    //down pressed
    else if(down_check())
    {
        if(airborne)
        {
        }
        if(state!=string('kneel'))
        {
            state = string('kneel');
        }
        target_hspeed = 0;
        core.gun_aim = -1; // ** x&lt;0=down ** x=0=off ** x&gt;0=up
    }
    else if(state=string('kneel'))
    {
        state=string('tonorm');
    }
    else if(state=string('kneel'))
    {
        target_hspeed = 0;
    }
    else
    {
        core.gun_aim = 0;
        //left and right keys pressed
        if(left_check() &amp;&amp; right_check())
        {
            target_hspeed = 0;
            walking=false;
        }
        //left key pressed
        else if(left_check())
        {
            walking=true;
            if(boosting)
            {
                boost_move_x(-2);
            }
            else
            {
                boost_move_x(-1);
            }
        }
        //right key pressed
        else if(right_check())
        {
            walking=true;
            if(boosting)
            {
                boost_move_x(2);
            }
            else
            {
                boost_move_x(1);
            }
        }
        //!left and !right pressed
        else
        {
            walking=false;
            target_hspeed = 0;
        }
        
        //jump pressed
        if(jump_check())
        {
            if(!airborne)
            {
                if(!boosting)
                {
                    state=string('jump');
                    jumpCounter = 0;
                    target_hspeed = 0;
                }
            }
            else{}
        }
        
        //boost pressed
        if(boost_check())
        {
            boosting=true;
            if(jump_check())
            {
                airborne = true;
                vspeed -= 3;
            }
        }
        else
        {
            boosting=false;
        }
        
        if(attack1_check())
        {
            core.attack1 = true;
        }
        if(attack2_check())
        {
            core.attack2 = true;
        }
    }
}
//choose dominant attack
attack_control(core.attack1,core.attack2);
//adjust state if needed
if(core.attack1)
{
    if(core.attack1_type!=2)
    {
        state=string('attack');
        target_hspeed = 0;
    }
}
if(core.attack2)
{
    if(core.attack2_type!=2)
    {
        state=string('attack');
        target_hspeed = 0;
    }
}


/***************************************************
  END Controls
 ***************************************************/

/***************************************************
  Physics
 ***************************************************/

/***************************************************
  Acceleration
 ***************************************************/

if(state = string('attack'))
{
    if(target_hspeed=0)
    {
        if(abs(hspeed) &lt;= 2)
        {
            hspeed = 0;
        }
        else
        {
            hspeed = hspeed/8;
        }
        core.x = x;
        
    }
}
else if(target_hspeed=0)
{
    if(abs(hspeed)&lt;=2)
    {
        hspeed = 0;
    }
    else if(hspeed&gt;0)
    {
        if(airborne){ hspeed -= 2; }
        else{ hspeed -= 4; }
    }
    else if(hspeed&lt;0)
    {
        if(airborne){ hspeed += 2; }
        else{ hspeed += 4; }
    }    
}
else if(target_hspeed&gt;hspeed)
{
    if(airborne){ hspeed += 2; }
    else{ hspeed += 4; }
}
else if(target_hspeed&lt;hspeed)
{
    if(airborne){ hspeed -= 2; }
    else{ hspeed -= 4; }
}


/***************************************************
  END Acceleration
 ***************************************************/

/***************************************************
  Gravity
 ***************************************************/

if(airborne)
{
    vspeed += 2; //*weight/1000
}
if(vspeed &lt; -32)
{
    vspeed = -32;
}
if(vspeed &gt; 40)
{
    vspeed = 40;
}

/***************************************************
  END Gravity
 ***************************************************/

/***************************************************
  END Physics
 ***************************************************/
 
/***************************************************
  Collision
 ***************************************************/
 

if(vspeed&gt;0)
{
    //check bottom left
    if(find_edge_below(x,y,-core.lefthalf,140,vspeed,land_parent))
    {
        if(state=string('shield'))
        {
            core.gun_aim = 0;
            with(shield_obj){instance_destroy()}
            state = string('tonorm');
            shield_counter = 0;
        }
        state = string('land');
    }
    //check bottom right
    else if(find_edge_below(x,y,core.righthalf,140,vspeed,land_parent))
    {
        if(state=string('shield'))
        {
            core.gun_aim = 0;
            with(shield_obj){instance_destroy()}
            state = string('tonorm');
            shield_counter = 0;
        }
        state = string('land');
    }
}
else if(vspeed&lt;0)
{
    //check top left
    if(find_edge_above(x,y,-core.lefthalf,-64,vspeed,land_parent)){}
    //check top right
    else{find_edge_above(x,y,core.righthalf,-64,vspeed,land_parent);}
}
if(hspeed&lt;0)
{
    //check left bottom
    if(find_edge_left(x,y,-core.lefthalf,64,hspeed,land_parent)){}
    //check left top
    else{find_edge_left(x,y,-core.lefthalf,-64,hspeed,land_parent);}
}
else if(hspeed&gt;0)
{
    //check right bottom
    if(find_edge_right(x,y,core.righthalf,64,hspeed,land_parent)){}
    //check right top
    else{find_edge_right(x,y,core.righthalf,-32,hspeed,land_parent);}
}

/***************************************************
  END Collision
 ***************************************************/

/***************************************************
  Image Transform
 ***************************************************/

if(hspeed!=0)
{
    image_xscale = hspeed/abs(hspeed);
    if(!boosting){core.image_xscale = image_xscale;}
}

/***************************************************
  END Image Transform
 ***************************************************/
 
/***************************************************
  State Controll
 ***************************************************/

if(state=string('tonorm'))
{
    counter += 1;
    if(counter&gt;=30)
    {
        state=string('normal');
        counter = 0;
    }
}

/***************************************************
  END State Controll
 ***************************************************/
 
 
//color code test
if(keyboard_check(ord('O')))
{
    color_tst += 1;
    color_tst2 = color_tst mod 5;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/***************************************************
  Positioning Code
 ***************************************************/

//Universal Positioning
core.vspeed = vspeed;
core.hspeed = hspeed;
//END Universal Positioning

/***************************************************
  Jump State
 ***************************************************/
 
if(state = string('jump'))
{
    if(jumpCounter&lt;5)
    {
        jumpCounter += 1;
        core.x = x;
        core.y = y_ease(core.y,y+20,4);
    }
    else if(jumpCounter=5)
    {
        jumpCounter = 100;
        core.x = x;
        core.y = y_ease(core.y,y+20,4);
        vspeed -= 28;
        airborne = true;
        state = string('tonorm');
    }
}

/***************************************************
  END Jump State
 ***************************************************/

/***************************************************
  Normal State
 ***************************************************/
 
else if(state = string('normal'))
{
    core.x = x;
    core.y = y;
    core.image_angle = angle_ease(core.image_angle,-hspeed*1.5,8);
}

/***************************************************
  END Normal State
 ***************************************************/

/***************************************************
  To Normal State
 ***************************************************/

else if(state = string('tonorm'))
{
    core.x = x_ease(core.x,x,4);
    core.y = y_ease(core.y,y,4);
    core.image_angle = angle_ease(core.image_angle,-hspeed*1.5,4);

}

/***************************************************
  END To Normal State
 ***************************************************/

/***************************************************
  Shield State
 ***************************************************/

else if(state = string('shield'))
{
    core.x = x_ease(core.x,x+35*core.image_xscale,8);
    core.y = y_ease(core.y,y+40,8);
    core.image_angle = angle_ease(core.image_angle,-25*core.image_xscale,4);
}

/***************************************************
  END Shield State
 ***************************************************/

/***************************************************
  Kneel State
 ***************************************************/

else if(state = string('kneel'))
{
    core.x = x_ease(core.x,x+35*core.image_xscale,8);
    core.y = y_ease(core.y,y+40,8);
    core.image_angle = angle_ease(core.image_angle,-15*core.image_xscale,4);
}

/***************************************************
  END Kneel State
 ***************************************************/

/***************************************************
  Slide Left State
 ***************************************************/

else if(state = string('slideL'))
{
    core.x = x;
    if(core.image_xscale = 1)
    {
        core.y = y_ease(core.y,y-35,4);
    }
    else
    {
        core.y = y-20;
    }
    core.image_xscale = 1;    
    core.image_angle = angle_ease(core.image_angle,hspeed,4);
    
}

/***************************************************
  END Slide Left State
 ***************************************************/

/***************************************************
  Slide Right State
 ***************************************************/

else if(state = string('slideR'))
{
    core.x = x;
    if(core.image_xscale = -1)
    {
        core.y = y_ease(core.y,y-35,4);
    }
    else
    {
        core.y = y-20;
    }
    core.image_xscale = -1;
    core.image_angle = angle_ease(core.image_angle,hspeed,4);
    
}

/***************************************************
  END Slide Right State
 ***************************************************/

/***************************************************
  Land State
 ***************************************************/

else if(state = string('land'))
{
    if(landCounter&gt;0)
    {
        landCounter -= 1;
        core.x = x;
        core.y = y_ease(core.y,y+landCounter*6,2);
    }
    else
    {
        state = string('tonorm');
    }
}

/***************************************************
  END Land State
 ***************************************************/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
